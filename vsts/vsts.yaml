name: $(BuildID)_$(BuildDefinitionName)_$(SourceBranchName)_$(Date:yyyyMMdd)$(Rev:.r)

# https://docs.microsoft.com/azure/devops/pipelines/process/runtime-parameters
parameters:
- name: maxParallelJobs
  displayName: Maximum jobs to run in parallel. Change maxParallel to 1 make OS builds run in serial rather than in parallel.
  type: number
  # Reasonable target to avoid throttling and contention with several PRs running.
  default: 4
- name: jobTimeoutInMinutes
  displayName: Timeout for each job
  type: number
  default: 120
- name: testTargets
  displayName: The .NET test targets to build and run. 'all' and 'min-matrix' (net6.0, netcore3.1) are aggregates of the remaining values.
  type: string
  values:
    - default
    - all
    - min-matrix
    - net6.0
    - net5.0
    - netcore3.1
    - netcore2.1
    - net4.7.2
    - net4.5.1
  default: default

variables:
# Variables for the buid/test matrix based on the 'testTargets' that turn on/off various test targets specifically or based on the 2 aggregates.
  ${{ if and(eq(parameters['testTargets'], 'default'), eq(variables['Build.Reason'], 'PullRequest')) }}:
    allTestTargets: 'False'
    minMatrix: 'True'
  ${{ elseif eq(parameters['testTargets'], 'default') }}:
    allTestTargets: 'True'
    minMatrix: 'True'
  ${{ else }}:
    allTestTargets: ${{ contains(parameters['testTargets'], 'all') }}
    # We wish to run the minimum test matrix targets if 1) directly specified, 2) if all targets was chosen.
    minMatrix: ${{ or(eq(parameters['testTargets'], 'min-matrix'), eq(variables['allTestTargets'], 'True')) }}

# The minimum matrix build/test targets.
  testNet60: ${{ or(eq(variables['minMatrix'], 'True'), contains(parameters['testTargets'], 'net6.0')) }}
  testNetcore31: ${{ or(eq(variables['minMatrix'], 'True'), contains(parameters['testTargets'], 'netcore3.1')) }}

# The remaining build/test targets.
  testNet50: ${{ or(eq(variables['allTestTargets'], 'True'), contains(parameters['testTargets'], 'net5.0')) }}
  testNetcore21: ${{ or(eq(variables['allTestTargets'], 'True'), contains(parameters['testTargets'], 'netcore2.1')) }}
  testNet472: ${{ or(eq(variables['allTestTargets'], 'True'), contains(parameters['testTargets'], 'net4.7.2')) }}
  testNet451: ${{ or(eq(variables['allTestTargets'], 'True'), contains(parameters['testTargets'], 'net4.5.1')) }}

trigger:
  batch: true
  branches:
    include:
    - main
  paths:
    exclude:
    - docs/*
    - tools/CaptureLogs/*
    - iothub/device/devdoc/*
    - iothub/service/devdoc/*

resources:
  - repo: self
    clean: true

jobs:
  ### Linux build ###
  - job: LINUX
    displayName: Linux
    timeoutInMinutes: ${{ parameters.jobTimeoutInMinutes }}
    strategy:
      maxParallel: ${{ parameters.maxParallelJobs }}
      matrix:
        .NET 6.0:
          FRAMEWORK: net6.0
          # Can't find a good way to skip matrix elements so for now we set an environment variable that the script will use to bail out.
          SHOULD_RUN: ${{ eq(variables['testNet60'], 'True') }}

    condition: succeeded()
    pool:
      # If this is changed, don't forget to update supported_platforms.md in the root directory. That document outlines what OS we test on and should stay up to date.
      vmImage: ubuntu-20.04
    steps:
      - task: PowerShell@2
        displayName: 'Print vars'
        inputs:
          targetType: inline
          script: |
            Write-Host "Build.Reason: ${{ variables['Build.Reason'] }}"
            Write-Host "jobTimeoutInMinutes: ${{ parameters.jobTimeoutInMinutes }}"
            Write-Host "maxParallelJobs: ${{ parameters.maxParallelJobs }}"
            Write-Host "minMatrix: ${{ variables.minMatrix }}"
            Write-Host "testNet60: ${{ variables.testNet60 }}"
            Write-Host "testNetcore31: ${{ variables.testNetcore31 }}"
            Write-Host "testNet50: ${{ variables.testNet50 }}"
            Write-Host "testNetcore21: ${{ variables.testNetcore21 }}"
            Write-Host "testNet472: ${{ variables.testNet472 }}"
            Write-Host "testNet451: ${{ variables.testNet451 }}"

      # https://docs.microsoft.com/azure/devops/pipelines/tasks/tool/dotnet-core-tool-installer?view=azure-devops

      # Linux requires .NET 6.0 install for tests to run, no matter which framework target is being tested
      - task: UseDotNet@2
        displayName: 'Use .NET SDK 6.0'
        inputs:
         packageType: sdk
         version: 6.x
         performMultiLevelLookup: true
         installationPath: $(Agent.ToolsDirectory)/dotnet

      - task: PowerShell@2
        displayName: 'Cert Validation - Setup Certificate Proxy'
        inputs:
          targetType: 'inline'
          script: |
            Write-Host "============"
            Write-Host "check docker"
            Write-Host "============"
            docker images
            docker ps -a
            gci -Path $(Build.SourcesDirectory)/e2e/test/docker -Recurse -Force -Name
            Write-Host "==========================="
            Write-Host "uncompress self-signed cert"
            Write-Host "==========================="
            gzip -d -N -S ".bin" $(Build.SourcesDirectory)/e2e/test/docker/haproxy/haproxy.bin
            gci -Path $(Build.SourcesDirectory)/e2e/test/docker -Recurse -Force -Name
            Write-Host "====================="
            Write-Host "Docker run containers"
            Write-Host "====================="

      - task: Bash@3
        displayName: 'Cert Validation - Setup local hostname'
        name: CVTEST_NET
        inputs:
          targetType: 'inline'
          script: |
            echo "==============="
            echo "Inspect network"
            echo "==============="
            ip -4 addr
            export CVTEST_HOST_IP=$(ip -4 addr show eth0 | grep -Po 'inet \K[\d.]+')
            export CVTEST_HOST_NETWORK=$(ip -4 addr show eth0 | grep -Po 'inet \K[\d.]+/*\d.')
            export CVTEST_HOST_SUBNET=$(ip -4 addr show eth0 | grep -Po 'inet \K[\d.]+' | grep -Po '[\d]{1,3}.[\d]{1,3}.[\d]{1,3}')
            export CVTEST_HOST_SUBNET_MASK=$(ip -4 addr show eth0 | grep -Po 'inet \K[\d.]+/*\d.' | grep -Po '/[\d]{1,2}')
            export CVTEST_CONTAINER_IP=$(ip -4 addr show docker0 | grep -Po 'inet \K[\d.]+')
            echo "HOST=$CVTEST_HOST_IP"
            echo "HOST NETWORK=$CVTEST_HOST_NETWORK"
            echo "HOST SUBNET=$CVTEST_HOST_SUBNET"
            echo "HOST SUBNET MASK=$CVTEST_HOST_SUBNET_MASK"
            echo "CONTAINER=$CVTEST_CONTAINER_IP"
            #echo "##vso[task.setvariable variable=AGENT_HOST;isoutput=true;]$CVTEST_HOST_IP"
            #echo "##vso[task.setvariable variable=AGENT_NETWORK;isoutput=true;]$CVTEST_HOST_NETWORK"
            #echo "##vso[task.setvariable variable=AGENT_SUBNET;isoutput=true;]$CVTEST_HOST_SUBNET"
            #echo "##vso[task.setvariable variable=AGENT_SUBNET_MASK;isoutput=true;]$CVTEST_HOST_SUBNET_MASK"
            #echo "##vso[task.setvariable variable=AGENT_CONTAINER;isoutput=true;]$CVTEST_CONTAINER_IP"
            #echo "=========="
            #echo "Ping hosts"
            #echo "=========="
            #ping -c 5 $CVTEST_HOST_IP
            #ping -c 5 $CVTEST_CONTAINER_IP
            #echo "=================="
            #echo "Inspect containers"
            #echo "=================="
            #docker ps -a
            #docker inspect invalid-gde
            #docker inspect invalid-dps
            #docker inspect invalid-hub
            export CVTEST_GDE_IP=$(docker inspect invalid-gde | grep -Po -m 1 '"IPAddress": "\K[\d.]+')
            export CVTEST_DPS_IP=$(docker inspect invalid-dps | grep -Po -m 1 '"IPAddress": "\K[\d.]+')
            export CVTEST_HUB_IP=$(docker inspect invalid-hub | grep -Po -m 1 '"IPAddress": "\K[\d.]+')
            echo "invalid-gde=$CVTEST_GDE_IP"
            echo "invalid-dps=$CVTEST_DPS_IP"
            echo "invalid-hub=$CVTEST_HUB_IP"
            #echo "##vso[task.setvariable variable=AGENT_GDE_IP;isoutput=true;]$CVTEST_GDE_IP"
            #echo "##vso[task.setvariable variable=AGENT_DPS_IP;isoutput=true;]$CVTEST_DPS_IP"
            #echo "##vso[task.setvariable variable=AGENT_HUB_IP;isoutput=true;]$CVTEST_HUB_IP"
            #echo "==============="
            #echo "Ping containers"
            #echo "==============="
            #docker ps -a
            #ping -c 2 $CVTEST_GDE_IP
            #ping -c 2 $CVTEST_DPS_IP
            #ping -c 2 $CVTEST_HUB_IP
            #cat /etc/hosts
            echo "================="
            echo "Update hosts file"
            echo "================="
            sudo bash -c 'mv /etc/hosts /etc/hosts.org'
            sudo bash -c 'cp /etc/hosts.org /etc/hosts'
            echo "$CVTEST_GDE_IP invalidcertgde1.westus.cloudapp.azure.com"
            echo "$CVTEST_DPS_IP invalidcertdps1.westus.cloudapp.azure.com"
            echo "$CVTEST_HUB_IP invalidcertiothub1.westus.cloudapp.azure.com"
            echo "" >> /tmp/hosts.cvtest
            echo "# Local host for invalid cert test" >> /tmp/hosts.cvtest
            echo "$CVTEST_GDE_IP invalidcertgde1.westus.cloudapp.azure.com" >> /tmp/hosts.cvtest
            echo "$CVTEST_DPS_IP invalidcertdps1.westus.cloudapp.azure.com" >> /tmp/hosts.cvtest
            echo "$CVTEST_HUB_IP invalidcertiothub1.westus.cloudapp.azure.com" >> /tmp/hosts.cvtest
            sudo bash -c 'cat /tmp/hosts.cvtest >> /etc/hosts'
            cat /etc/hosts
            echo "====================="
            echo "Ping containers (URL)"
            echo "====================="
            pwd
            ls -al ../../_temp/*.ps1
            echo "===================="
            echo "READING .ps1 SCRIPTS IN _temp"
            echo "===================="
            cat ../../_temp/*.ps1


      - powershell: ./vsts/gatedBuild.ps1
        displayName: build
        env:
          # Environment variables for IoT Hub E2E tests
          IOTHUB_CONNECTION_STRING: $(IOTHUB-CONNECTION-STRING)
          IOTHUB_DEVICE_CONN_STRING: $(IOTHUB-DEVICE-CONN-STRING)
          IOTHUB_X509_DEVICE_PFX_CERTIFICATE: $(IOTHUB-X509-DEVICE-PFX-CERTIFICATE)
          IOTHUB_X509_DEVICE_PFX_THUMBPRINT: $(IOTHUB-X509-DEVICE-PFX-THUMBPRINT)

          IOTHUB_X509_CHAIN_DEVICE_NAME: $(IOTHUB-X509-CHAIN-DEVICE-NAME)
          IOTHUB_X509_CHAIN_DEVICE_PFX_CERTIFICATE: $(IOTHUB-X509-CHAIN-DEVICE-PFX-CERTIFICATE)
          IOTHUB_USER_ASSIGNED_MSI_RESOURCE_ID: $(IOTHUB-USER-ASSIGNED-MSI-RESOURCE-ID)
          IOT_HUB_SAS_KEY: $(IOTHUB-SAS-KEY)
          IOT_HUB_SAS_KEY_NAME: $(IOTHUB-SAS-KEY-NAME)

          # Environment variables for DPS E2E tests
          DPS_IDSCOPE: $(DPS-IDSCOPE)
          PROVISIONING_CONNECTION_STRING: $(PROVISIONING-CONNECTION-STRING)
          DPS_GLOBALDEVICEENDPOINT: $(DPS-GLOBALDEVICEENDPOINT)
          DPS_X509_PFX_CERTIFICATE_PASSWORD: $(DPS-X509-PFX-CERTIFICATE-PASSWORD)
          DPS_X509_GROUP_ENROLLMENT_NAME: $(DPS-X509-GROUP-ENROLLMENT-NAME)

          # Environment variables for Azure resources used for E2E tests (common)
          X509_CHAIN_ROOT_CA_CERTIFICATE: $(X509-CHAIN-ROOT-CA-CERTIFICATE)
          X509_CHAIN_INTERMEDIATE1_CERTIFICATE: $(X509-CHAIN-INTERMEDIATE1-CERTIFICATE)
          X509_CHAIN_INTERMEDIATE2_CERTIFICATE: $(X509-CHAIN-INTERMEDIATE2-CERTIFICATE)
          X509_CHAIN_INTERMEDIATE2_PFX_CERTIFICATE: $(X509-CHAIN-INTERMEDIATE2-PFX-CERTIFICATE)
          STORAGE_ACCOUNT_CONNECTION_STRING: $(STORAGE-ACCOUNT-CONNECTION-STRING)
          MSFT_TENANT_ID: $(MSFT-TENANT-ID)
          E2E_TEST_AAD_APP_CLIENT_ID: $(E2E-TEST-AAD-APP-CLIENT-ID)
          E2E_TEST_AAD_APP_CLIENT_SECRET: $(E2E-TEST-AAD-APP-CLIENT-SECRET)
          E2E_IKEY: $(E2E-IKEY)

          # Environment variables for the DevOps pipeline
          PROXY_SERVER_ADDRESS: 127.0.0.1:8888
          TARGET_BRANCH: $(System.PullRequest.TargetBranch)
          FRAMEWORK: $(FRAMEWORK)

          # Environment variables for invalid certificate tests
          IOTHUB_DEVICE_CONN_STRING_INVALIDCERT: $(IOTHUB-DEVICE-CONN-STRING-INVALIDCERT)
          IOTHUB_CONN_STRING_INVALIDCERT: $(IOTHUB-CONN-STRING-INVALIDCERT)
          DPS_GLOBALDEVICEENDPOINT_INVALIDCERT: $(DPS-GLOBALDEVICEENDPOINT-INVALIDCERT)
          PROVISIONING_CONNECTION_STRING_INVALIDCERT: $(PROVISIONING-CONNECTION-STRING-INVALIDCERT)

          # Environment variables used by Log Analytics Workspace for Azure Security Center
          LA_AAD_APP_ID: $(LA-AAD-APP-ID)
          LA_AAD_APP_CERT_BASE64: $(LA-AAD-APP-CERT-BASE64)
          LA_WORKSPACE_ID: $(LA-WORKSPACE-ID)

          # Environment variable for running samples/cleanups
          PATH_TO_DEVICE_PREFIX_FOR_DELETION_FILE: $(PATH-TO-DEVICE-PREFIX-FOR-DELETION-FILE)
          FAR_AWAY_IOTHUB_CONNECTION_STRING: $(FAR-AWAY-IOTHUB-CONNECTION-STRING)
          PNP_TC_DEVICE_CONN_STRING: $(PNP-TC-DEVICE-CONN-STRING)
          PNP_THERMOSTAT_DEVICE_CONN_STRING: $(PNP-THERMOSTAT-DEVICE-CONN-STRING)
          DPS_SYMMETRIC_KEY_INDIVIDUAL_ENROLLMENT_REGISTRATION_ID: $(DPS-SYMMETRIC-KEY-INDIVIDUAL-ENROLLMENT-REGISTRATION-ID)
          DPS_SYMMETRIC_KEY_INDIVIDUAL_ENROLLEMNT_PRIMARY_KEY: $(DPS-SYMMETRIC-KEY-INDIVIDUAL-ENROLLEMNT-PRIMARY-KEY)

      - task: CopyFiles@2
        displayName: "Copy files to the artifacts folder"
        inputs:
          SourceFolder: "$(Build.SourcesDirectory)"
          Contents: "**/*.trx"
          TargetFolder: "$(Build.ArtifactStagingDirectory)"

        condition: always()

      - task: PublishBuildArtifacts@1
        displayName: "Publish Artifact: testresults_linux_$(FRAMEWORK)"
        inputs:
          ArtifactName: testresults_linux_$(FRAMEWORK)

        condition: always()

      - task: PublishTestResults@2
        displayName: "Publish Test Results **/*.trx"
        inputs:
          testRunner: VSTest
          testRunTitle: "Linux Tests ($(FRAMEWORK)) (Attempt $(System.JobAttempt))"
          testResultsFiles: "**/*.trx"

        condition: always()
        
      - task: ComponentGovernanceComponentDetection@0
        displayName: Component Governance Detection
        inputs:
          scanType: 'Register'
          verbosity: 'Verbose'
          alertWarningLevel: 'Low' # The task will present a warning, but will not cause the build to fail
        condition: always()
