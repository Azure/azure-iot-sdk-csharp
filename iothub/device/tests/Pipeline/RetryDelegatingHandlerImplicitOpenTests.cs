// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Azure.Devices.Client.Transport;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using NSubstitute;

namespace Microsoft.Azure.Devices.Client.Test
{
    [TestClass]
    [TestCategory("Unit")]
    public class RetryDelegatingHandlerImplicitOpenTests
    {
        [TestMethod]
        public async Task OpenAsyncNextCompletedSubjIsOpen()
        {
            var contextMock = Substitute.For<PipelineContext>();
            contextMock.ConnectionStatusChangeHandler = (connectionStatusInfo) => { };
            var nextHandlerMock = Substitute.For<IDelegatingHandler>();
            nextHandlerMock.OpenAsync(Arg.Any<CancellationToken>()).Returns(t => Task.CompletedTask);

            var cancellationToken = new CancellationToken();
            var sut = new RetryDelegatingHandler(contextMock, nextHandlerMock);
            await sut.OpenAsync(cancellationToken).ConfigureAwait(false);
        }

        [TestMethod]
        public async Task ImplicitOpenSubjWasNotOpenSubjIsOpen()
        {
            var contextMock = Substitute.For<PipelineContext>();
            contextMock.ConnectionStatusChangeHandler = (connectionStatusInfo) => { };
            var nextHandlerMock = Substitute.For<IDelegatingHandler>();
            nextHandlerMock.OpenAsync(Arg.Any<CancellationToken>()).Returns(t => Task.CompletedTask);
            nextHandlerMock.SendEventAsync(Arg.Any<OutgoingMessage>(), Arg.Any<CancellationToken>()).Returns(t => Task.CompletedTask);
            nextHandlerMock.SendEventAsync(Arg.Any<IEnumerable<OutgoingMessage>>(), Arg.Any<CancellationToken>()).Returns(t => Task.CompletedTask);
            nextHandlerMock.WaitForTransportClosedAsync().Returns(Task.Delay(TimeSpan.FromSeconds(10)));
            var cancellationToken = new CancellationToken();
            var actions = new Func<IDelegatingHandler, Task>[]
            {
                sut => sut.SendEventAsync(new OutgoingMessage(), cancellationToken),
                sut => sut.SendEventAsync(new[] { new OutgoingMessage() }, cancellationToken),
            };

            foreach (Func<IDelegatingHandler, Task> action in actions)
            {
                var sut = new RetryDelegatingHandler(contextMock, nextHandlerMock);
                await sut.OpenAsync(cancellationToken).ConfigureAwait(false);
                await action(sut).ConfigureAwait(false);
            }

            await nextHandlerMock.Received(actions.Length).OpenAsync(Arg.Any<CancellationToken>()).ConfigureAwait(false);
        }

        [TestMethod]
        public async Task Retry_CloseAsyncBeforeOpen_Ok()
        {
            var contextMock = Substitute.For<PipelineContext>();
            var nextHandlerMock = Substitute.For<IDelegatingHandler>();
            nextHandlerMock.CloseAsync(CancellationToken.None).Returns(t => Task.CompletedTask);

            var sut = new RetryDelegatingHandler(contextMock, nextHandlerMock);
            await sut.CloseAsync(CancellationToken.None).ConfigureAwait(false);
        }

        [TestMethod]
        public async Task Retry_CloseAsyncSuccessDisposesHandler_Throws()
        {
            var contextMock = Substitute.For<PipelineContext>();
            contextMock.ConnectionStatusChangeHandler = (connectionStatusInfo) => { };
            var nextHandlerMock = Substitute.For<IDelegatingHandler>();
            var cancellationToken = new CancellationToken();

            nextHandlerMock.OpenAsync(cancellationToken).Returns(t => Task.CompletedTask);
            nextHandlerMock.CloseAsync(cancellationToken).Returns(t => Task.CompletedTask);

            var sut = new RetryDelegatingHandler(contextMock, nextHandlerMock);
            await sut.OpenAsync(cancellationToken).ConfigureAwait(false);
            await sut.CloseAsync(cancellationToken).ConfigureAwait(false);

            await ((Func<Task>)(() => sut.OpenAsync(cancellationToken))).ExpectedAsync<ObjectDisposedException>().ConfigureAwait(false);
        }

        [TestMethod]
        public async Task OpenAsyncTwoCallersOnlyOneOpenCalled()
        {
            var contextMock = Substitute.For<PipelineContext>();
            contextMock.ConnectionStatusChangeHandler = (connectionStatusInfo) => { };
            var tcs = new TaskCompletionSource<int>();
            var nextHandlerMock = Substitute.For<IDelegatingHandler>();
            int callCounter = 0;
            nextHandlerMock.OpenAsync(Arg.Any<CancellationToken>()).Returns(t =>
            {
                callCounter++;
                return tcs.Task;
            });
            nextHandlerMock.WaitForTransportClosedAsync().Returns(Task.Delay(TimeSpan.FromSeconds(10)));

            var sut = new RetryDelegatingHandler(contextMock, nextHandlerMock);
            var cancellationToken = new CancellationToken();
            Task firstOpen = sut.OpenAsync(cancellationToken);
            Task secondOpen = sut.OpenAsync(cancellationToken);
            tcs.TrySetResult(0);
            await Task.WhenAll(firstOpen, secondOpen).ConfigureAwait(false);

            Assert.AreEqual(1, callCounter);
        }

        [TestMethod]
        public async Task OpenAsyncNextFailedSutIsOpenAndCanBeReopen()
        {
            var contextMock = Substitute.For<PipelineContext>();
            contextMock.ConnectionStatusChangeHandler = (connectionStatusInfo) => { };
            var nextHandlerMock = Substitute.For<IDelegatingHandler>();
            bool shouldThrow = true;

            nextHandlerMock.OpenAsync(Arg.Any<CancellationToken>()).Returns(ci =>
            {
                if (shouldThrow)
                {
                    throw new IOException();
                }
                else
                {
                    return Task.CompletedTask;
                }
            });

            var sut = new RetryDelegatingHandler(contextMock, nextHandlerMock);
            var cancellationToken = new CancellationToken();
            await sut.OpenAsync(cancellationToken).ExpectedAsync<IOException>().ConfigureAwait(false);

            shouldThrow = false;

            await sut.OpenAsync(cancellationToken).ConfigureAwait(false);
        }

        [TestMethod]
        public async Task OpenAsyncNextCancelledSutIsOpenAndCanBeReopen()
        {
            var contextMock = Substitute.For<PipelineContext>();
            contextMock.ConnectionStatusChangeHandler = (connectionStatusInfo) => { };
            var tcs = new TaskCompletionSource<int>();
            tcs.SetCanceled();
            var nextHandlerMock = Substitute.For<IDelegatingHandler>();
            nextHandlerMock.OpenAsync(Arg.Any<CancellationToken>()).Returns(tcs.Task);

            var sut = new RetryDelegatingHandler(contextMock, nextHandlerMock);
            var cancellationToken = new CancellationToken();
            await sut.OpenAsync(cancellationToken).ExpectedAsync<TaskCanceledException>().ConfigureAwait(false);

            nextHandlerMock.OpenAsync(Arg.Any<CancellationToken>()).Returns(t => Task.CompletedTask);

            await sut.OpenAsync(cancellationToken).ConfigureAwait(false);
        }
    }
}
