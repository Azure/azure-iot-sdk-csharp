// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using FluentAssertions;
using Microsoft.Azure.Devices.Client.Transport;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Moq;

namespace Microsoft.Azure.Devices.Client.Test
{
    [TestClass]
    [TestCategory("Unit")]
    public class RetryDelegatingHandlerImplicitOpenTests
    {
        [TestMethod]
        public async Task OpenAsyncNextCompletedSubjIsOpen()
        {
            var contextMock = new PipelineContext();
            contextMock.ConnectionStatusChangeHandler = (connectionStatusInfo) => { };
            var nextHandlerMock = new Mock<IDelegatingHandler>();
            nextHandlerMock.Setup(x => x.OpenAsync(It.IsAny<CancellationToken>())).Returns(() => Task.CompletedTask);

            var sut = new RetryDelegatingHandler(contextMock, nextHandlerMock.Object);
            await sut.OpenAsync(CancellationToken.None).ConfigureAwait(false);
        }

        [TestMethod]
        public async Task NoImplicitOpenByClientMethods()
        {
            var contextMock = new PipelineContext();
            contextMock.ConnectionStatusChangeHandler = (connectionStatusInfo) => { };
            var nextHandlerMock = new Mock<IDelegatingHandler>();
            nextHandlerMock.Setup(x => x.OpenAsync(It.IsAny<CancellationToken>())).Returns(() => Task.CompletedTask);
            nextHandlerMock.Setup(x => x.SendTelemetryAsync(It.IsAny<TelemetryMessage>(), It.IsAny<CancellationToken>())).Returns(() => Task.CompletedTask);
            nextHandlerMock.Setup(x => x.SendTelemetryBatchAsync(It.IsAny<IEnumerable<TelemetryMessage>>(), It.IsAny<CancellationToken>())).Returns(() => Task.CompletedTask);
            nextHandlerMock.Setup(x => x.WaitForTransportClosedAsync()).Returns(() => Task.Delay(TimeSpan.FromSeconds(10)));
            var actions = new Func<IDelegatingHandler, Task>[]
            {
                sut => sut.SendTelemetryAsync(new TelemetryMessage(), CancellationToken.None),
                sut => sut.SendTelemetryBatchAsync(new[] { new TelemetryMessage() }, CancellationToken.None),
            };

            foreach (Func<IDelegatingHandler, Task> action in actions)
            {
                var sut = new RetryDelegatingHandler(contextMock, nextHandlerMock.Object);
                await sut.OpenAsync(CancellationToken.None).ConfigureAwait(false);
                await action(sut).ConfigureAwait(false);
            }

            nextHandlerMock.Verify(x => x.OpenAsync(It.IsAny<CancellationToken>()), Times.Exactly(actions.Length));
        }

        [TestMethod]
        public async Task Retry_CloseAsyncBeforeOpen_Ok()
        {
            var contextMock = new PipelineContext();
            var nextHandlerMock = new Mock<IDelegatingHandler>();
            nextHandlerMock.Setup(x => x.CloseAsync(CancellationToken.None)).Returns(() => Task.CompletedTask);

            var sut = new RetryDelegatingHandler(contextMock, nextHandlerMock.Object);
            await sut.CloseAsync(CancellationToken.None).ConfigureAwait(false);
        }

        [TestMethod]
        public async Task OpenAsync_SynchronizesToOneInnerCallToOpen()
        {
            var contextMock = new PipelineContext();
            contextMock.ConnectionStatusChangeHandler = (csi) => { }; // avoid NRE

            int callCounter = 0;
            var nextHandlerMock = new Mock<IDelegatingHandler>();
            nextHandlerMock
                .Setup(x => x.OpenAsync(CancellationToken.None))
                .Returns(() =>
                    {
                        callCounter++;
                        return Task.CompletedTask;
                    });

            var sut = new RetryDelegatingHandler(contextMock, nextHandlerMock.Object);

            // Simutaneously run two calls to open
            await Task
                .WhenAll(
                    sut.OpenAsync(CancellationToken.None),
                    sut.OpenAsync(CancellationToken.None))
                .ConfigureAwait(false);

            callCounter.Should().Be(1);
        }

        [TestMethod]
        public async Task OpenAsyncNextFailedSutIsOpenAndCanBeReopen()
        {
            var contextMock = new PipelineContext();
            contextMock.ConnectionStatusChangeHandler = (connectionStatusInfo) => { };
            var nextHandlerMock = new Mock<IDelegatingHandler>();
            bool shouldThrow = true;

            nextHandlerMock
                .Setup(x => x.OpenAsync(It.IsAny<CancellationToken>()))
                .Returns(() =>
                    shouldThrow
                        ? throw new IotHubClientException()
                        : Task.CompletedTask);

            var sut = new RetryDelegatingHandler(contextMock, nextHandlerMock.Object);
            Func<Task> act = () => sut.OpenAsync(CancellationToken.None);

            await act.Should().ThrowAsync<IotHubClientException>();

            shouldThrow = false;

            await sut.OpenAsync(CancellationToken.None).ConfigureAwait(false);
        }

        [TestMethod]
        public async Task OpenAsync_AfterCancelled_CanBeReopened()
        {
            // arrange

            var contextMock = new PipelineContext();
            contextMock.ConnectionStatusChangeHandler = (csi) => { }; // avoid NRE

            var nextHandlerMock = new Mock<IDelegatingHandler>();
            nextHandlerMock
                .Setup(x => x.OpenAsync(CancellationToken.None))
                .Returns(() => throw new OperationCanceledException());

            var sut = new RetryDelegatingHandler(contextMock, nextHandlerMock.Object);

            // act and assert
            Func<Task> actual = () => sut.OpenAsync(CancellationToken.None);
            await actual.Should().ThrowAsync<OperationCanceledException>();

            // arrange again

            nextHandlerMock
                .Setup(x => x.OpenAsync(CancellationToken.None))
                .Returns(() => Task.CompletedTask);

            // act and assert again
            actual = () => sut.OpenAsync(CancellationToken.None);
            await actual.Should().NotThrowAsync();
        }
    }
}
